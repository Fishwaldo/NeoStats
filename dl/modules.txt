How to Write a NeoStats Module, and not stuff it all up! Version 0.1
------------------------------------------------------------------------------

Ok, Prelim Document, so if its rough, and you can't figure something out,
look at the source ok?

NeoStats now Supports Modules, that can be loaded at run time to add
functionality to it. these Modules are not limited to a Statistical Software
anymore, but can perform any Function you want on the network.

Currently, there are 3 or 4 modules that Ship with NeoStats, these are:

spam.so -> Remember the Spam user, that always changed his nick, but thats
about all he did?

well, the spam user is to help catch people that Spam your network
advertising anything from Porn Sites, to other IRC networks. Basically what
it does is sit on the Network and wait for a *Normal* user to send it a
message.. If a Oper sends it a message, it just ignores it. If the Spam user
gets a message, it will broadcast it via Globops, and also in the Services
channel, so you opers can decide if its a legit Spammer, and what to do with
them (Kill??).
Thats all it does...

version.so -> is a very simple module to show you how to write Modules. If
you looking to do something more Complex, then look at the source of spam.c
or statserv.c, as these two Modules use most of the Functionality provided
by the Module API.

statserv.so -> Good Ol StatServ... he is still here, but now has a module of
his own... Nothing has really changed from the version 1.1.2... if you are a
old user of NeoStats, then you should have no questions about statserv at
all..

icqserv.so -> the newest member of NeoStats, proving that anything is
possible with Neo... Basically, its a IRC->ICQ gateway... allowing you to
send messages from IRC to users on ICQ.. they can even reply back to you via
Icqserv if they know the write syntax... not much Documentation on it yet..
the Online help should get you started... yeah, the source is complicated,
but if you have problems, please, try to give me some more info than just
"It crashes" I know it crashes... I need to know why it crashes!!!

Ok, so thats the current Modules we have.. Basically they are showing you
that u can add your own Bots to NeoStats... But you can do more than just
that... You can also add your own IRCD support (Currently, NeoStats Natively
Supports Unreal... we are going to update this soon)

So, your feeling very very lucky, and want to write your own wiz bang
Services? Ok... Get out the asprin, cause this is gonna be fun....

______________________________________________________________________________

Anything that the Server recieves from users, or other servers can be
intercepted by a Module... 

Lets use example.c as example here... I'll detail each part of it....


#include <stdio.h>
#include "dl.h"
#include "stats.h"

ok, Firstly, you have to include a few files.
"dl.h" is mandatory, needed for the Module API... 
"stats.h" is also a pretty good idea, if you want to use some of the
Internal Functions of NeoStats. If your Module is going to have a Bot in it,
then its Mandatory as well...


Module_Info my_info[] = { {
	"example",
	"example Module Description",
	"version 1.0"
} };

Module_Info *__module_get_info() {
	return my_info;
};

ok, a pretty lame coding style, but hey, it works, so who cares at the
moment.
Every Module must be able to return a array describing the Module Name, a
Short Description and a *Text* based version number.
The First field is used when refercing modules (eg, unloading a Module) the
second field is the description... the third field is a Version number...
Like I said, its text based, but could be just numbers for all you care.. it
can be used by other modules that might rely on it to make sure if version
compatible... 

Functions my_fn_list[] = {
	{ "VERSION", 	new_m_version,  1 }
	{ NULL,		NULL,		0 }
};


Functions *__module_get_functions() {
	return my_fn_list;
};

ok, here is where we define what commands we want to be routed to this
Module. In this case, if a user typed /version <NeoStats Server name> then
this Module would intercept it... (note that with most commands, the Base
NeoStats also would intercept it) so in this case, both the NeoStats and
Module would return information. again. my_fn_list[] is a array. the first
field is what command you want to intercept it Could be "NICK" or
whatever... the Second field is the name of the function in the module that
will get this command... and finally the third field helps identify if you
want to see commands that come from the locally connected servers (eg, if it
squits NeoStats) or if you want to see commands that come form the network
in General. In this case, 1 means that we want Network Commands... 
the end of the array must be NULL terminated, meaning that the TEXT fields
must be null, and the numeric fields must be 0. 


EventFnList my_event_list[] = {
	{ "ONLINE", 	Online},
	{ NULL, 	NULL}
};


EventFnList *__module_get_events() {
	return my_event_list;
};


Ok, this is Internal Functions Lists that you want to trigger on. Examples
of them are ONLINE, trigged when NeoStats is Connected to the IRC network,
or SIGNON when a new user signs on... This list is pretty small at the
moment, but will grow as we add more features. Currently, as I speak, only
ONLINE is active.. and very usefull (as you will see below) Again, the
first field is the event you want to monitor, second is the function to
trigger when this event is activated. Again, NULL terminate the array.


void _fini() {
	log("unloading Spam");
};

void _init() {
	log("Loaded Module");
}

Two Special Functions that can be helpfull if  you have to initilize
databases or close them down (or whatever else you might need to do) 
NOTE: DO NOT USE _init to start up bots or whatever. NeoStats might not even
be connected to a IRC network when _init is fired. Basically, Don't use init
to start anything that is going to try to send commands to the IRC network.
use it to Initilize a database, or read in a config file... _init is called
even before the module is fully loaded.... 
_fini is called when the module is unloaded, probably the very last thing
that happens, so if you need to close log files, or flush out a database
cache then here is the place to do it... 

now, some special functions to use as well, like init and fini:


init_bot(nick, ident, hostname, realname, modes, my_info[0].module_name);

init_bot is a function in the Main program that Registers a Bot on the
network for you. DON'T just think that you can send a "NICK mybot" out to
the network cause it won't work. PRIVMSG's and NOTICES are handled in a
special way, and each module has to register its bots via this interface.

init bot will return 1 on success, or if there is a failure of somereason,
then it will return -1. A failure might be that the nickname already exists
on the network, in which case, you would have to try a new Nick.

bot_nick_change(currentnick, newnick)

Bot_nick is used to change the Nickname of a bot. Because the Bot Nicknames
are registered internally in NeoStats, you must call this function to change
the nickname... again, will return 1 on success, or -1 if the nickname is
already registered on the network.

del_bot(nick, reason)
This functions makes your Bot Quit from the Network, and unregisters the
name with NeoStats.. if you try to LOG off a nickname that isn't registered,
then it will return -1 otherwise on success, it returns 1


int __Bot_Message(char *origin, char *message, int type)

This function in your Module is called whenever a bot that has been
registered like above recieves a message from the Network. If you are
programing a Bot, this this is the Interface for all PRIVMSG's and NOTICE's
the Variables passed to it are as follows:

origin -> who sent the Message to you.. It could be a Nick or could be a
server message

message -> The actuall message that was sent to you..

type -> the type of message that was sent to you, eg, 1 is PRIVMSG, 2 is
NOTICE

add_mod_timer(function name, timername, my_info[0].module_name, interval);

Ahh, have a need for Timers in your Module.. Well here is how you do them...
again, you have to register your function with NeoStats, just like you would
with a Bot.

the variables are:
Function name -> the Name of the function you want to trigger when this
timer is triggered

timername -> a descriptive name of the Timer...

my_info[0].module_name -> must be the same as what you passed to NeoStats
for the module name... to stop muckups, I use the actual Variable I passed.

interval -> The Interval in Seconds that this Function can be run... 

A word of Warning about timers.. These are not precision timers. when I say
Interval, all it does is say, "has this many seconds passed since I last ran
this function. If you specified 60 seconds for the Function, it might not
get run till 66 seconds. Because NeoStats is Single Threaded, it runs in a
continues loop, meaning that if NeoStats itself, or another Module held up
that loop, then the timers are not going to run untill that peice of code
gives up... 

int del_mod_timer(char *timername)

ahhh, finished running your timers, and want to delete them, then just call
this function with the timername u used above, and volia, the timer will be
deleted.


This is the Main API for Modules in a Nutshell.. I suggest you look at
spam.c to see how it all fits together.. Spam.c is a fairly simple module,
but uses most of these API's. Of course there is nothing to stop you useing
other Functions that are in the core NeoStats at the moment, but Don't come
wingeing to me if these change... 

I'll be adding more to the Module API as we go atm, and at the time of
writting, we hadn't even released a beta of it.... Hopefully before we make
a full release, I'll update this document.

Things I'm planning to implement into the API:
*Logging with levels
*a interface to the Internal User lists (needed Badly if you want your Module
to interact with users)
*a socket API, so you can write Modules that need to use some sort of Sockets
(of course you could write your own module, with the socket functions
included in it, but then, what about blocking and timeouts, your module
could potentially hang the rest of NeoStats)
*Maybe the option to have some modules run in their own threads... An example
of this would be a Open Socks/Wingate Scanner.. you don't want NeoStats
hanging while it tries to connect to the host that just connected do you? I
havn't had anything to do with Threading yet, so that might have to wait a
version or two...
*anything else you need to make your Module work..

at the moment, I know of the issue of not every platform supporting Dynamic
Libaries... So I'm going to work on linking in static libaries... but that
could take me a while... so if your host doesn't have Dynamic Libary suport,
then find one that does if you really want to run NeoStats... Don't bug me
about it...


Thats about it...
Comments and suggestions are welcome at: fish@dynam.ac 
or you can find me on one of these networks occasionally:
irc.global-irc.net
irc.dynam.ac
irc.chatnet.org

